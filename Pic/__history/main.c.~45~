#include <16F877A.h>
#device ADC=10

#FUSES NOWDT                    //No Watch Dog Timer
#FUSES NOBROWNOUT               //No brownout reset
#FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O

#use delay(crystal=20000000)

#use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=Serial)

#ifndef lcd_enable                                                             
   #define lcd_enable     pin_e1      // pino enable do LCD
   #define lcd_rs         pin_e2      // pino rs do LCD
   #define lcd_d4         pin_d4      // pino de dados d4 do LCD
   #define lcd_d5         pin_d5      // pino de dados d5 do LCD
   #define lcd_d6         pin_d6      // pino de dados d6 do LCD
   #define lcd_d7         pin_d7      // pino de dados d7 do LCD
#endif

#include <mod_lcd.c>

long leituraADC(int canal){
   set_adc_channel(canal);
   delay_us(10);
   return read_adc();
}

long entrada, temperatura, passos = 0,  to = 0;
long y = 0, y0 = 0, kp = 1, T1 = 0.005, Tal = 0.8;
long u = 0, u0 = 0, e = 0, e0 = 0, t2 = 0.005, ti = 0.075;

#INT_RTCC
void  RTCC_isr(void) 
{
//!   entrada = read_adc();
//!   temperatura= 30;
//!   //1000ms/0,0542ms = 18.45 -> 19 ciclos
//!   //5000ms/0,0542ms = 92 ciclos
//!   //(19*valor)/1020 -> valor*(19/1020) -> valor*0.0186274509803922
//!   
//!   
//!   
//!   if(passos <= to){
//!      output_high(PIN_C5);
//!   }else{
//!      output_low(PIN_C5);
//!   }
//!   
//!   passos++;
//!   if(passos == 92){
//!      passos = 0;
//!      e = entrada - u;
//!      u = u0+kp*(e-e0*(10));
//!      e0 = e;
//!      u0 = u;
//!      
//!      //to = u*0.019;
//!
//!      printf(lcd_escreve,"\f Entrada %Lu \n",entrada);
//!      printf(lcd_escreve,"\r Saida %Lu \n",u);
      
//!   }
   

   
   
}

void main()
{
   setup_adc_ports(AN0_AN1_AN2_AN3_AN4);
   set_adc_channel(0);
   delay_us(10);
   
   lcd_ini();
   delay_ms(10);
   
   
   setup_adc(ADC_CLOCK_DIV_16);
   setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1|RTCC_8_bit);      //51,2 us overflow
   setup_timer_2(T2_DIV_BY_16,255,1);      //819 us overflow, 819 us interrupt

   setup_ccp1(CCP_PWM);
   set_pwm1_duty((int16)510);

   enable_interrupts(INT_RTCC);
   enable_interrupts(GLOBAL);

   while(TRUE)
   {

      entrada = read_adc()/100;
      //Planta
      y = kp*(T1/Tal)*u0+(Ti-T1)*y0/Tal;
      e = entrada - y;
      y0 = y;
      //Controle
      u = u0+kp*(e-e0+e0*T2/ti);
      u0 = u;
      e0 = e;
     
      
      printf(lcd_escreve,"\f Entrada %Lu \n",entrada);
      printf(lcd_escreve,"\r Saida %Lu \n",u);
      delay_ms(50);
   }

}
